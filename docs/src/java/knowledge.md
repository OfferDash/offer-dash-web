# Java 高频考点

## 语言基础

****

### 基本数据类型

****

| **数据类型** | **字节大小**       | **范围**                                                                 | **备注**                               |
|--------------|--------------------|--------------------------------------------------------------------------|----------------------------------------|
| **byte**     | 1 字节（8 位）     | -128 到 127                                                             |                                        |
| **short**    | 2 字节（16 位）    | -32,768 到 32,767                                                       |                                        |
| **int**      | 4 字节（32 位）    | -2,147,483,648 到 2,147,483,647                                         |                                        |
| **long**     | 8 字节（64 位）    | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807                | 结尾需加 `L`（如 `100L`）              |
| **float**    | 4 字节（32 位）    | 约 ±3.40282347E+38<br>（有效位数：6-7 位）                               | 结尾需加 `f`（如 `3.14f`）             |
| **double**   | 8 字节（64 位）    | 约 ±1.79769313486231570E+308<br>（有效位数：15 位）                      | 默认小数类型（如 `3.14`）              |
| **char**     | 2 字节（16 位）    | 0 到 65,535（对应 Unicode 字符，如 `'A'`、`'中'`）                       | 用单引号表示（如 `'a'`）               |
| **boolean**  | 不固定（通常 1 位/字节） | `true` 或 `false`                                                       | JVM 可能优化为 1 位或占用 1 字节空间   |

****

### 自动装箱拆箱

****

自动拆箱：将包装类自动转换为基础类型

自动装箱：将基础类型自动转换为包装类型

```java
Integer a = 10; // 自动装箱
int b = a;      // 自动拆箱
```

原理：

```java
Integer a = Integer.valueOf(100);  // 自动装箱
int b = a.intValue();              // 自动拆箱
```

自动装箱拆箱场景：

- 基本数据类型放入集合类，会将基础类型自动装箱为包装类型
- 基本类型和包装类型比大小会自动拆箱为基本类型比较

注意，对于 `Integer` 是存在缓存的：

```
Integer a = 100;
Integer b = 100;
System.out.println(a == b);
```

结果为 `true`，因为 Java5 引入了缓存机制导致 -128 ~ 127 范围内直接采用缓存中的对象比较，因此在这个范围内的 `Integer` 对象的判断是相等的，在 Java6 中可以通过设置虚拟机参数：`-XX AutoBoxCacheMax=size` 修改

****

### == 跟 equals 区别

****

**`==` 运算符**：

   - 用于比较两个变量的引用，即判断它们是否指向同一个对象。
   - 对于基本数据类型（如 `int`、`char` 等），`==` 比较的是它们的值。

   示例：

   ```java
   String str1 = new String("hello");
   String str2 = new String("hello");
   System.out.println(str1 == str2); // 输出 false，因为它们是不同的对象
   ```

**`equals()` 方法**：

   - 用于比较两个对象的内容（即它们的状态）。
   - 默认情况下，`Object` 类中的 `equals()` 方法与 `==` 相同，但通常会被重写，以实现基于内容的比较。

   示例：

   ```java
   System.out.println(str1.equals(str2)); // 输出 true，因为内容相同
   ```

综上：

- 使用 `==` 比较引用（内存地址）。
- 使用 `equals()` 比较内容（逻辑相等性）。 

在比较字符串或自定义对象时，通常应该使用 `equals()` 方法。

****

### 接口和抽象类的区别

****

| **对比项**               | **接口（Interface）**                                                                 | **抽象类（Abstract Class）**                                                                 |
|--------------------------|-------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|
| **定义**                 | 定义方法的规范，不包含具体实现（仅方法声明）。                                       | 不能被直接实例化的类，可包含抽象方法和具体方法。                                              |
| **示例**                 | `PayService` 接口，声明 `pay` 方法。                                                | `AbstractPayService` 抽象类，实现 `PayService` 接口并提供 `pay` 方法的具体逻辑。             |
| **方法实现**             | - Java 8 前：所有方法默认抽象，无实现代码。<br>- Java 8 后：支持 `default` 默认方法。 | 可包含抽象方法（需子类实现）和具体方法（可直接继承使用）。                                      |
| **成员变量**             | 默认是 `public static final`，必须显式初始化。                                      | 可以定义任意访问修饰符（`private`/`protected`/`public`）的成员变量，无需强制初始化。           |
| **构造器**               | 无构造器。                                                                          | 可以有构造器（用于初始化成员变量），但类本身不能被实例化。                                     |
| **继承与实现**           | 类通过 `implements` 实现接口，支持多实现。                                           | 类通过 `extends` 继承抽象类，仅支持单继承。                                                   |
| **设计目的**             | 强调行为规范（“能做什么”），如定义跨类别的通用能力。                                 | 提供部分共性实现（“是什么”），用于复用代码和约束子类行为。                                     |
| **适用场景**             | 需要统一方法规范但实现逻辑多样的场景（如支付、日志等）。                             | 需要封装部分公共逻辑，同时强制子类实现特定方法的场景（如模板模式）。                          |


**注意事项**：
   - 在实际开发中，通常会先定义接口，然后实现接口。
   - 如果多个实现类中有共同的可复用代码，可以在接口和实现类之间添加一个抽象类，将公共代码提取到抽象类中。

## 集合相关

****

### ArrayList 和 LinkedList

****

| **特性**           | **ArrayList**                                                                 | **LinkedList**                                                                 |
|--------------------|-------------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| **存储结构**       | 基于动态数组，直接存储数据内容。                                              | 基于双向链表，存储节点（Node），每个节点包含数据及前后指针。                    |
| **查询效率**       | 支持下标随机访问，时间复杂度为 **O(1)**。                                     | 不支持下标访问，需从头/尾遍历链表，平均时间复杂度为 **O(n)**。                  |
| **修改效率**  | 1.尾部操作：无扩容时 **O(1)**（扩容时需复制数组）。<br>2.非尾部操作：需移动元素，时间复杂度 **O(n)**。 | 插入/删除只需修改相邻节点的指针，时间复杂度 **O(1)**（但定位操作仍需 **O(n)**）。 |
| **线程安全**     | 非线程安全，需通过 `Collections.synchronizedList` 包装或使用局部变量。        | 同 ArrayList，需外部同步或使用线程安全容器。                                    |
| **适用场景**       | 频繁查询、尾部增删。                                                          | 频繁在任意位置插入/删除。                                                      |

**ArrayList 扩容规则**：
- 调用 `ensureCapacity` 方法，将数据长度乘以1.5倍。
- 底层源码实现：当前数量 + 当前数量 `>>` 1位 相当于除以2。

**ArrayList的Fail-Fast机制**

- 通过记录 `modCount` 参数来实现，增减元素会改变 `modCount` 的值。
- 在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。

****

### HashMap

****

| **对比项**       | **JDK 1.7**                                  | **JDK 1.8**                                  |
|------------------|---------------------------------------------|---------------------------------------------|
| **数据结构**      | 数组 + 链表（链表散列）                       | 数组 + 链表 + 红黑树                         |
| **结构转换**  | 无红黑树结构                                 | 链表长度 ≥ 8，且散列数组长度 ≥ 64 时转红黑树     |
| **数组长度**  | 允许非 2 的幂次方长度 | 强制为 2 的幂次方长度（可以位运算优化哈希计算）    |
| **哈希计算**  | 通过取模计算槽位                             | 用 `hash & (n-1)` 替代取模      |
| **扩容时机**      | 插入数据前扩容            | 插入数据后扩容（避免无效扩容，减少内存浪费）   |
| **扩容逻辑**  | 所有元素重新计算哈希并分配槽位                 | 通过高位判断元素是否迁移到新槽位（性能优化）   |
| **插入逻辑** | 链表使用头插法（可能导致死循环）               | 链表使用尾插法       |

**为什么要在1.8之后改成尾插法**：
- 1.7是头插法 1.8尾插法，链表头部插入元素会导致元素顺序和插入顺序颠倒，尾插法在尾部插入保持原来的顺序
- 多线程扩容时容易产生并发死循环：
  - 线程 A 和线程 B 同时对同一个桶进行操作，线程 A 正在进行扩容操作，而线程 B 正在向该桶插入新元素
  - 由于头插法的特性，线程 B 插入的新元素会成为链表的新头节点
  - 由于扩容操作会将原链表的节点逆序插入到新链表中，线程 A 可能会在逆序过程中读取到线程 B 插入的新头节点

**负载因子为什么选择0.75**：
- 假设一个bucket空和非空的概率为0.5，通过二项式定理计算，当容量趋于无穷大时，合理值大概在0.7左右。
- 由于临界值（threshold）= 负载因子（loadFactor）* 容量（capacity），而容量永远是2的幂。
- 为了保证负载因子与容量的乘积是一个整数，0.75 是一个比较合理的选择，因为这个数与任何2的幂相乘的结果都是整数。

****

### ConcurrentHashMap

****

| **对比项**            | **JDK 1.7**                                                                 | **JDK 1.8**                                                                 |
|-----------------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| **数据结构**          | 分段数组（`Segment`）+ 链表（每个 `Segment` 独立锁）                         | 数组 + 链表 + 红黑树（类似 HashMap，锁粒度细化到链表头或树根节点）            |
| **锁机制**            | 分段锁（`ReentrantLock`），每个 `Segment` 独立加锁                           | `CAS` + `synchronized` 锁单个桶（链表头或树根节点），锁粒度更小              |
| **并发限制**            | 由 `Segment` 数量决定（默认 16），并发性能受限于分段数                       | 无固定分段，锁粒度细化到桶级别，理论上并发度更高                              |
| **哈希计算**          | 两次哈希（先定位 `Segment`，再定位桶）                                      | 单次哈希（直接定位桶），优化哈希算法减少冲突                                  |
| **扩容机制**          | 每个 `Segment` 独立扩容，扩容期间阻塞该分段的写操作                          | 多线程协同扩容（迁移数据时，其他线程可协助完成桶迁移）                        |
| **迭代器特性**        | 弱一致性（迭代过程中可能反映其他线程的修改）                                 | 弱一致性，但实现更高效（基于快照或分段遍历）                                  |

**为什么在1.8废弃了分段锁**：
- 锁粒度优化：通过对单个节点加锁，降低了锁的竞争。
- 锁性能优化：很多更新操作使用无锁的CAS操作，提高了效率，尤其在读多写少的场景下。
- 内存优化：通过减少锁的数量和使用更简洁的数据结构，提高了内存效率。
